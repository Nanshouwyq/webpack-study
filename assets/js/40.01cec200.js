(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{447:function(t,s,a){"use strict";a.r(s);var e=a(35),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("vue中nextTick")]),t._v(" "),a("h2",{attrs:{id:"js运行机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js运行机制"}},[t._v("#")]),t._v(" js运行机制")]),t._v(" "),a("p",[t._v("JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤:")]),t._v(" "),a("p",[t._v('所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\n主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。\n一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n主线程不断重复上面的第三步。')]),t._v(" "),a("p",[t._v("主线程的执行，而所有的异步结果都是通过 “任务队列” 来调度。 消息队列中存放的是一个个的任务（task）。 规范中规定 task 分为两大类，分别是 macro task 和 micro task，并且每个 macro task 结束后，都要清空所有的 micro task。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("macroTask "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" macroTaskQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1. Handle current MACRO-TASK")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("handleMacroTask")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2. Handle all MICRO-TASK")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("microTask "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" microTaskQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("handleMicroTask")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("microTask"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("在浏览器环境中 :")]),t._v(" "),a("p",[t._v("常见的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate")]),t._v(" "),a("p",[t._v("常见的 micro task 有 MutationObsever 和 Promise.then"),a("br"),t._v("\n异步更新队列\n可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。")]),t._v(" "),a("p",[t._v("如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。")]),t._v(" "),a("p",[t._v("然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。")]),t._v(" "),a("p",[t._v("Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。")]),t._v(" "),a("p",[t._v("在 vue2.5 的源码中，macrotask 降级的方案依次是：setImmediate、MessageChannel、setTimeout")]),t._v(" "),a("p",[t._v("vue 的 nextTick 方法的实现原理:")]),t._v(" "),a("p",[t._v("vue 用异步队列的方式来控制 DOM 更新和 nextTick 回调先后执行\nmicrotask 因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕\n考虑兼容问题,vue 做了 microtask 向 macrotask 的降级方案")])])}),[],!1,null,null,null);s.default=n.exports}}]);